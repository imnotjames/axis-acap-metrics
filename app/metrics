#!/bin/sh

APP_NAME=$(basename $0)
BUFFER_FILE=$(mktemp /tmp/${APP_NAME}.XXXXXX)

GetParameters() {
  cat $1 | grep '=' | \
  while read -r PARAM_LINE; do
    KEY=$(echo "${APP_NAME}_${PARAM_LINE}" | sed -r 's/^([^=]*)=(.*)/\1/' | tr '[:lower:]' '[:upper:]')
    VALUE=$(echo "${APP_NAME}_${PARAM_LINE}" | sed -r 's/^([^=]*)=(.*)/\2/')

    echo "export $KEY=$VALUE"
  done
}

QueueMetric() {
  METRIC_HOST=$(hostname)

  METRIC_NAME=$1
  METRIC_TYPE=$2
  METRIC_DATA=$3
  METRIC_META=$4
  METRIC_HELP=$5

  if [ -n "${METRIC_TYPE}" ]; then
    echo "# TYPE ${METRIC_NAME} ${METRIC_TYPE}" >> "$BUFFER_FILE"
  fi

  if [ -n "${METRIC_HELP}" ]; then
    echo "# HELP ${METRIC_NAME} ${METRIC_HELP//$'\n'/ }" >> "$BUFFER_FILE"
  fi

  echo "${METRIC_NAME}{${METRIC_META}} ${METRIC_DATA}" >> "$BUFFER_FILE"
}

FlushMetrics() {
  if [ ! -s "$BUFFER_FILE" ]; then
    # If the metrics queue file is empty or doesn't exist
    # then we don't need to flush
    rm -f "$BUFFER_FILE"
    return 0
  fi

  eval $(GetParameters "/etc/sysconfig/storage.conf")
  eval $(GetParameters "conf/$APP_NAME.conf")

  if [ -z "$METRICS_SITE" ]; then
    echo "No metrics site defined"
    return 0
  fi

  if [ -z "$METRICS_JOB" ]; then
    echo "No metrics job defined"
    return 0
  fi

  if [ -z "$METRICS_INSTANCE" ]; then
    METRICS_INSTANCE=$(hostname)
  fi

  echo "Flushing metrics"

  BUFFER=$(cat "$BUFFER_FILE" | sort --version-sort -r | uniq)

  echo "$BUFFER"

  if [ -n "${METRICS_USERNAME}${METRICS_PASSWORD}" ]; then
    echo "$BUFFER" | curl -i -f \
      -X PUT \
      --user "${METRICS_USERNAME}:${METRICS_PASSWORD}" \
      --output /dev/null \
      --no-progress-meter \
      --max-time 60 \
      --data-binary @- \
      "https://${METRICS_SITE}/metrics/job/${METRICS_JOB}/instance/${METRICS_INSTANCE}"
  else
    echo "$BUFFER" | curl -i -f \
      -X PUT \
      --output /dev/null \
      --no-progress-meter \
      --max-time 60 \
      --data-binary @- \
      "https://${METRICS_SITE}/metrics/job/${METRICS_JOB}/instance/${METRICS_INSTANCE}"
  fi

  # Clear the queue
  rm -f "$BUFFER_FILE"

  echo "Flush complete"
}


QueueCPUMetrics() {
  CPU_STATS=$(cat /proc/stat | grep 'cpu  ' | sed 's/^cpu  //')

  CPU_USER=$(echo "$CPU_STATS" | cut -d' ' -f 1)
  QueueMetric "cpu_user" "gauge" "${CPU_USER}"

  CPU_SYSTEM=$(echo "$CPU_STATS" | cut -d' ' -f 3)
  QueueMetric "cpu_system" "gauge" "${CPU_SYSTEM}"

  CPU_IDLE=$(echo "$CPU_STATS" | cut -d' ' -f 4)
  QueueMetric "cpu_idle" "gauge" "${CPU_IDLE}"

  CPU_IOWAIT=$(echo "$CPU_STATS" | cut -d' ' -f 5)
  QueueMetric "cpu_iowait" "gauge" "${CPU_IOWAIT}"

  CPU_IRQ=$(echo "$CPU_STATS" | cut -d' ' -f 6)
  QueueMetric "cpu_interrupt" "gauge" "${CPU_IRQ}"

  CPU_STEAL=$(echo "$CPU_STATS" | cut -d' ' -f 8)
  QueueMetric "cpu_stolen" "gauge" "${CPU_STEAL}"

  CPU_GUEST=$(echo "$CPU_STATS" | cut -d' ' -f 9)
  QueueMetric "cpu_guest" "gauge" "${CPU_GUEST}"
}


QueueDiskMetrics() {
  TARGET_DISK=$1
  DISK_META="device=\"${TARGET_DISK}\""
  
  DISK_STATS=$(df | grep "^${TARGET_DISK}" | head -n1)

  DISK_TOTAL_KB=$(echo $DISK_STATS | cut -d' ' -f 2)
  DISK_TOTAL=$(( $DISK_TOTAL_KB * 1024 ))
  DISK_USED_KB=$(echo $DISK_STATS | cut -d' ' -f 3)
  DISK_USED=$(($DISK_USED_KB * 1024))
  DISK_FREE_KB=$(echo $DISK_STATS | cut -d' ' -f 4)
  DISK_FREE=$(($DISK_FREE_KB * 1024))

  DISK_UTILIZED=$(( 100 * $DISK_USED / $DISK_TOTAL ))

  if [ $DISK_UTILIZED -lt 10 ]; then
    DISK_IN_USE="0.0${DISK_UTILIZED}"
  elif [ $DISK_UTILIZED -lt 100 ]; then
    DISK_IN_USE="0.${DISK_UTILIZED}"
  else
    DISK_IN_USE="1.00"
  fi

  QueueMetric "disk_free" "gauge" "$DISK_FREE" "$DISK_META"
  QueueMetric "disk_in_use" "gauge" "$DISK_IN_USE" "$DISK_META"
  QueueMetric "disk_total" "gauge" "$DISK_TOTAL" "$DISK_META"
  QueueMetric "disk_used" "gauge" "$DISK_USED" "$DISK_META"
  QueueMetric "disk_utilized" "gauge" "$DISK_UTILIZED" "$DISK_META"
}


QueueDiagnosticMetrics() {
  QueueCPUMetrics
  
  DISKS=$(df | grep '\(^/dev/\|^vcrfs\)' | cut -d' ' -f1 | sort | uniq)
  for TARGET_DISK in $DISKS; do
    QueueDiskMetrics "$TARGET_DISK"
  done

  UPTIME_SECONDS=$(cat /proc/uptime | cut -d' ' -f 1)
  QueueMetric "uptime" "gauge" "${UPTIME_SECONDS}"
}

# Do an initial flush of any old metrics in case of some kind of a failure
FlushMetrics

while true; do
  QueueDiagnosticMetrics
  FlushMetrics

  sleep ${METRICS_INTERVAL:-60}
done
