#!/bin/sh

APP_NAME=$(basename $0)
BUFFER_FILE=$(mktemp /tmp/${APP_NAME}.XXXXXX)


GetParameters() {
  cat $1 | grep '=' | \
  while read -r PARAM_LINE; do
    KEY=$(echo "${APP_NAME}_${PARAM_LINE}" | sed -r 's/^([^=]*)=(.*)/\1/' | tr '[:lower:]' '[:upper:]')
    VALUE=$(echo "${APP_NAME}_${PARAM_LINE}" | sed -r 's/^([^=]*)=(.*)/\2/')

    echo "export $KEY=$VALUE"
  done
}


QueueMetric() {
  METRIC_HOST=$(hostname)

  METRIC_NAME=$1
  METRIC_TYPE=$2
  METRIC_DATA=$3
  METRIC_META=$4
  METRIC_HELP=$5

  if [ -n "${METRIC_TYPE}" ]; then
    echo "# TYPE ${METRIC_NAME} ${METRIC_TYPE}" >> "$BUFFER_FILE"
  fi

  if [ -n "${METRIC_HELP}" ]; then
    echo "# HELP ${METRIC_NAME} ${METRIC_HELP//$'\n'/ }" >> "$BUFFER_FILE"
  fi

  echo "${METRIC_NAME}{${METRIC_META}} ${METRIC_DATA}" >> "$BUFFER_FILE"
}


FlushMetrics() {
  if [ ! -s "$BUFFER_FILE" ]; then
    # If the metrics queue file is empty or doesn't exist
    # then we don't need to flush
    rm -f "$BUFFER_FILE"
    return 0
  fi

  eval $(GetParameters "/etc/sysconfig/storage.conf")
  eval $(GetParameters "conf/$APP_NAME.conf")

  if [ -z "$METRICS_SITE" ]; then
    echo "No metrics site defined"
    return 0
  fi

  if [ -z "$METRICS_JOB" ]; then
    echo "No metrics job defined"
    return 0
  fi

  if [ -z "$METRICS_INSTANCE" ]; then
    METRICS_INSTANCE=$(hostname)
  fi

  echo "Flushing metrics"

  # Sort is unreliable here - if we use `sort` we end up with
  # inconsistent handling of symbols.  Instead, we snag all the
  # comments then all the other values
  BUFFER_COMMENTS=$(grep "^#" "$BUFFER_FILE" | sort | uniq)
  BUFFER_METRICS=$(grep -v "^#" "$BUFFER_FILE" | sort | uniq)

  BUFFER=$(echo -e "${BUFFER_COMMENTS}\n\n${BUFFER_METRICS}")

  echo "$BUFFER"

  if [ -n "${METRICS_USERNAME}${METRICS_PASSWORD}" ]; then
    echo "$BUFFER" | curl -i -f \
      -X PUT \
      --user "${METRICS_USERNAME}:${METRICS_PASSWORD}" \
      --output /dev/null \
      --no-progress-meter \
      --max-time 60 \
      --data-binary @- \
      "https://${METRICS_SITE}/metrics/job/${METRICS_JOB}/instance/${METRICS_INSTANCE}"
  else
    echo "$BUFFER" | curl -i -f \
      -X PUT \
      --output /dev/null \
      --no-progress-meter \
      --max-time 60 \
      --data-binary @- \
      "https://${METRICS_SITE}/metrics/job/${METRICS_JOB}/instance/${METRICS_INSTANCE}"
  fi

  # Clear the queue
  rm -f "$BUFFER_FILE"

  echo "Flush complete"
}


QueueCPUMetrics() {
  CPU_STATS="$(cat /proc/stat | grep 'cpu[0-9]' | sed 's/^cpu\([0-9]\+\)\s*/\1 /')"

  USER_HZ=100

  echo "$CPU_STATS" | while read -r CPU_LINE; do
    CPU_ID=$(echo "$CPU_LINE" | cut -d' ' -f 1)
    CPU_USER=$(( $(echo "$CPU_LINE" | cut -d' ' -f 2) / $USER_HZ ))
    CPU_NICE=$(( $(echo "$CPU_LINE" | cut -d' ' -f 3) / $USER_HZ ))
    CPU_SYSTEM=$(( $(echo "$CPU_LINE" | cut -d' ' -f 4) / $USER_HZ ))
    CPU_IDLE=$(( $(echo "$CPU_LINE" | cut -d' ' -f 5) / $USER_HZ ))
    CPU_IOWAIT=$(( $(echo "$CPU_LINE" | cut -d' ' -f 6) / $USER_HZ ))
    CPU_IRQ=$(( $(echo "$CPU_LINE" | cut -d' ' -f 7) / $USER_HZ ))
    CPU_SOFTIRQ=$(( $(echo "$CPU_LINE" | cut -d' ' -f 8) / $USER_HZ ))
    CPU_STEAL=$(( $(echo "$CPU_LINE" | cut -d' ' -f 9) / $USER_HZ ))

    QueueMetric "node_cpu_seconds_total" "counter" "${CPU_USER}" "cpu=\"${CPU_ID}\",mode=\"user\""
    QueueMetric "node_cpu_seconds_total" "counter" "${CPU_NICE}" "cpu=\"${CPU_ID}\",mode=\"nice\""
    QueueMetric "node_cpu_seconds_total" "counter" "${CPU_SYSTEM}" "cpu=\"${CPU_ID}\",mode=\"system\""
    QueueMetric "node_cpu_seconds_total" "counter" "${CPU_IDLE}" "cpu=\"${CPU_ID}\",mode=\"idle\""
    QueueMetric "node_cpu_seconds_total" "counter" "${CPU_IOWAIT}" "cpu=\"${CPU_ID}\",mode=\"iowait\""
    QueueMetric "node_cpu_seconds_total" "counter" "${CPU_IRQ}" "cpu=\"${CPU_ID}\",mode=\"irq\""
    QueueMetric "node_cpu_seconds_total" "counter" "${CPU_SOFTIRQ}" "cpu=\"${CPU_ID}\",mode=\"softirq\""
    QueueMetric "node_cpu_seconds_total" "counter" "${CPU_STEAL}" "cpu=\"${CPU_ID}\",mode=\"steal\""
  done
}


QueueDiskMetrics() {
  TARGET_DISK=$1

  DISK_STATS=$(
    df -T -P \
      | grep "^${TARGET_DISK}" \
      | head -n1 \
      | sed 's/\s\+/ /g'
  )

  DISK_DEVICE=$(echo $DISK_STATS | cut -d' ' -f 1)
  DISK_TYPE=$(echo $DISK_STATS | cut -d' ' -f 2)
  DISK_MOUNTPOINT=$(echo $DISK_STATS | cut -d' ' -f 7)

  DISK_TOTAL_KB=$(echo $DISK_STATS | cut -d' ' -f 3)
  DISK_TOTAL=$(($DISK_TOTAL_KB * 1024))
  DISK_USED_KB=$(echo $DISK_STATS | cut -d' ' -f 4)
  DISK_USED=$(($DISK_USED_KB * 1024))
  DISK_AVAIL_KB=$(echo $DISK_STATS | cut -d' ' -f 5)
  DISK_AVAIL=$(($DISK_AVAIL_KB * 1024))

  DISK_FREE=$(( $DISK_TOTAL - $DISK_USED ))

  DISK_META="device=\"${DISK_DEVICE}\""
  DISK_META="${DISK_META},fstype=\"${DISK_TYPE}\""
  DISK_META="${DISK_META},mountpoint=\"${DISK_MOUNTPOINT}\""

  QueueMetric "node_filesystem_size_bytes" "gauge" "$DISK_TOTAL" "$DISK_META"
  QueueMetric "node_filesystem_avail_bytes" "gauge" "$DISK_AVAIL" "$DISK_META"
  QueueMetric "node_filesystem_free_bytes" "gauge" "$DISK_FREE" "$DISK_META"
}


QueueMemoryMetrics() {
  MEMORY_STATS=$(free | grep '^Mem:' | sed 's/\s\+/ /g')

  MEMORY_TOTAL=$(echo $MEMORY_STATS | cut -d' ' -f 2)
  MEMORY_USED=$(echo $MEMORY_STATS | cut -d' ' -f 3)
  MEMORY_FREE=$(echo $MEMORY_STATS | cut -d' ' -f 4)
  MEMORY_SHARED=$(echo $MEMORY_STATS | cut -d' ' -f 5)
  MEMORY_CACHED=$(echo $MEMORY_STATS | cut -d' ' -f 6)
  MEMORY_AVAILABLE=$(echo $MEMORY_STATS | cut -d' ' -f 7)

  QueueMetric "node_memory_MemTotal_bytes" "gauge" "$MEMORY_TOTAL"
  QueueMetric "node_memory_MemFree_bytes" "gauge" "$MEMORY_FREE"
  QueueMetric "node_memory_Shmem_bytes" "gauge" "$MEMORY_SHARED"
  QueueMetric "node_memory_Cached_bytes" "gauge" "$MEMORY_CACHED"

  SWAP_STATS=$(free | grep '^Swap:' | sed 's/\s\+/ /g')
  SWAP_STATS=${SWAP_STATS:-swap 0 0 0}

  SWAP_TOTAL=$(echo $SWAP_STATS | cut -d' ' -f 2)
  SWAP_USED=$(echo $SWAP_STATS | cut -d' ' -f 3)
  SWAP_FREE=$(echo $SWAP_STATS | cut -d' ' -f 4)

  QueueMetric "node_memory_SwapTotal_bytes" "gauge" "$SWAP_TOTAL"
  QueueMetric "node_memory_SwapCached_bytes" "gauge" "$SWAP_USED"
  QueueMetric "node_memory_SwapFree_bytes" "gauge" "$SWAP_FREE"
}


QueueDiagnosticMetrics() {
  QueueCPUMetrics
  QueueMemoryMetrics

  DISKS=$(df | grep '\(^/dev/\|^vcrfs\)' | cut -d' ' -f1 | sort | uniq)
  for TARGET_DISK in $DISKS; do
    QueueDiskMetrics "$TARGET_DISK"
  done

  CURRENT_TIME=$(date '+%s')
  QueueMetric "node_time_seconds" "gauge" "$CURRENT_TIME"

  BOOT_TIME=$(cat /proc/stat | grep '^btime' | cut -d' ' -f 2)
  QueueMetric "node_boot_time_seconds" "gauge" "$BOOT_TIME"
}

# Do an initial flush of any old metrics in case of some kind of a failure
FlushMetrics

while true; do
  QueueDiagnosticMetrics
  FlushMetrics

  sleep ${METRICS_INTERVAL:-60}
done
